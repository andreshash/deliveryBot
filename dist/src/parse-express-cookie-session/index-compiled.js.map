{"version":3,"sources":["index.js"],"names":[],"mappings":"AAAA;;AAEA,IAAI,IAAI,QAAQ,YAAR,CAAR;AACA,IAAI,SAAS,SAAS,MAAT,CAAgB,OAAhB,EAAyB;AACpC,OAAK,IAAL,GAAY,GAAZ;AACA,OAAK,MAAL,GAAc,IAAd;AACA,OAAK,QAAL,GAAgB,IAAhB;AACA;AACD,CALD;;AAOA,IAAI,SAAS,kBAAb;AACA,IAAI,SAAS,kBAAb;;AAEA,OAAO,SAAP,CAAiB,SAAjB,GAA6B,UAAU,GAAV,EAAe,GAAf,EAAoB;;AAE/C,MAAI,YAAY,SAAS,SAAT,CAAmB,IAAnB,EAAyB,GAAzB,EAA8B,GAA9B,EAAmC;AACjD,UAAM,OAAO,EAAb;AACA,QAAI,MAAM,IAAI,MAAJ,IAAc,MAAxB;AACA,QAAI,QAAQ,CAAC,OAAO,GAAP,GAAa,IAAI,GAAJ,CAAd,CAAZ;;AAEA,QAAI,IAAI,MAAR,EAAgB,MAAM,IAAN,CAAW,aAAa,IAAI,MAA5B;AAChB,QAAI,IAAI,MAAR,EAAgB,MAAM,IAAN,CAAW,YAAY,IAAI,MAA3B;AAChB,QAAI,IAAI,IAAR,EAAc,MAAM,IAAN,CAAW,UAAU,IAAI,IAAzB;AACd,QAAI,IAAI,OAAR,EAAiB,MAAM,IAAN,CAAW,aAAa,IAAI,OAAJ,CAAY,WAAZ,EAAxB;AACjB,QAAI,IAAI,QAAR,EAAkB,MAAM,IAAN,CAAW,UAAX;AAClB,QAAI,IAAI,MAAR,EAAgB,MAAM,IAAN,CAAW,QAAX;;AAEhB,WAAO,MAAM,IAAN,CAAW,IAAX,CAAP;AACD,GAbD;AAcA,SAAO,UAAU,GAAV,EAAe,GAAf,EAAoB,IAApB,CAAP;AACD,CAjBD;;AAmBA,IAAI,sBAAsB,SAAS,mBAAT,CAA6B,WAA7B,EAA0C;AAClE,MAAI,CAAC,WAAD,IAAgB,CAAC,YAAY,EAA7B,IAAmC,CAAC,YAAY,YAApD,EAAkE;AAChE;AACA,UAAM,IAAN,CAAW,MAAX;AACA;AACD;AACD,QAAM,IAAN,CAAW,YAAX,GAA0B,MAAM,MAAN,CAAa,OAAb,CAAqB,OAArB,CAA1B;AACA,QAAM,IAAN,CAAW,YAAX,CAAwB,cAAxB,GAAyC,IAAzC;AACA,QAAM,IAAN,CAAW,YAAX,CAAwB,EAAxB,GAA6B,YAAY,EAAzC;AACA,QAAM,IAAN,CAAW,YAAX,CAAwB,aAAxB,GAAwC,YAAY,YAApD;AACA,QAAM,IAAN,CAAW,YAAX,CAAwB,uBAAxB;AACA,QAAM,IAAN,CAAW,YAAX,CAAwB,aAAxB;AACA,QAAM,IAAN,CAAW,YAAX,CAAwB,WAAxB,GAAsC,CAAC,EAAD,CAAtC;AACD,CAbD;;AAeA,IAAI,6BAA6B,SAAS,0BAAT,GAAsC;AACrE,MAAI,IAAI,MAAM,IAAN,CAAW,OAAX,EAAR;AACA,MAAI,CAAC,CAAL,EAAQ;AACN;AACD;AACD,SAAO,EAAE,IAAI,EAAE,EAAR,EAAY,cAAc,EAAE,eAAF,EAA1B,EAAP;AACD,CAND;;AAQA,OAAO,OAAP,GAAiB,UAAU,OAAV,EAAmB;AAClC,YAAU,WAAW,EAArB;AACA,MAAI,MAAM,QAAQ,GAAR,IAAe,YAAzB;AACA,MAAI,gBAAgB,QAAQ,MAAR,IAAkB,EAAtC;AACA,MAAI,sBAAsB,EAAE,UAAU,IAAZ,EAAkB,QAAQ,IAA1B,EAA1B;AACA;AACA,kBAAgB,EAAE,QAAF,CAAW,mBAAX,EAAgC,aAAhC,CAAhB;;AAEA,SAAO,SAAS,yBAAT,CAAmC,GAAnC,EAAwC,GAAxC,EAA6C,IAA7C,EAAmD;;AAExD;AACA;;AAEA;AACA,QAAI,kBAAkB,IAAI,MAA1B;AACA,QAAI,EAAE,OAAF,CAAU,eAAV,CAAJ,EAAgC;AAC9B,YAAM,IAAI,KAAJ,CAAU,qDAAqD,oDAA/D,CAAN;AACD;AACD,QAAI,SAAS,IAAI,MAAJ,CAAW,aAAX,CAAb;;AAEA;AACA,QAAI,IAAI,WAAJ,CAAgB,OAAhB,CAAwB,OAAO,IAA/B,MAAyC,CAA7C,EAAgD;AAC9C,aAAO,MAAP;AACD;;AAED;AACA;AACA;AACA,QAAI,mBAAJ;AACA,QAAI,aAAJ,CArBwD,CAqBrC;AACnB,QAAI,gBAAgB,IAAI,OAAJ,CAAY,GAAZ,CAApB;AACA,QAAI,CAAC,EAAE,OAAF,CAAU,aAAV,CAAL,EAA+B;AAC7B,UAAI;;AAEF,wBAAgB,KAAK,KAAL,CAAW,aAAX,CAAhB;AACA;AACA,YAAI,iBAAiB,CAAC,cAAc,EAAhC,IAAsC,CAAC,cAAc,YAAzD,EAAuE;AACrE,gBAAM,iBAAN;AACD;AACD;;;AAGD,OAVD,CAUE,OAAO,CAAP,EAAU;AACV;AACA,gBAAQ,IAAR,CAAa,8BAAb;AACD;AACF;AACD,wBAAoB,aAApB;AACA;AACA;AACA,QAAI,EAAJ,CAAO,QAAP,EAAiB,YAAY;AAC3B,UAAI,sBAAsB,4BAA1B;AACA;AACA,UAAI,EAAE,WAAF,CAAc,mBAAd,CAAJ,EAAwC;AACtC,eAAO,OAAP,GAAiB,IAAI,IAAJ,CAAS,CAAT,CAAjB;AACA,YAAI,SAAJ,CAAc,YAAd,EAA4B,OAAO,SAAP,CAAiB,GAAjB,EAAsB,EAAtB,CAA5B;AACA;AACD;;AAED;AACA;;;;;AAKA;AACA,sBAAgB,mBAAhB;AACA;AACA,UAAI,kBAAkB,aAAtB,EAAqC;AACnC,YAAI,MAAM,KAAK,SAAL,CAAe,mBAAf,CAAV;AACA,cAAM,OAAO,SAAP,CAAiB,GAAjB,EAAsB,GAAtB,CAAN;AACA,YAAI,SAAJ,CAAc,YAAd,EAA4B,GAA5B;AACA;AACA;AACA;AACD;AACF,KA1BD;;AA4BA,QAAI,QAAQ,SAAR,IAAqB,CAAC,mBAAmB,MAAM,IAAN,CAAW,OAAX,EAAnB,CAA1B,EAAoE;AAClE,YAAM,IAAN,CAAW,OAAX,GAAqB,KAArB,GAA6B,IAA7B,CAAkC,UAAU,IAAV,EAAgB;AAChD;AACD,OAFD,EAEG,YAAY;AACb;AACA,cAAM,IAAN,CAAW,MAAX;AACA;AACD,OAND;AAOD,KARD,MAQO;AACL;AACD;AACF,GAjFD;AAkFD,CA1FD","file":"index-compiled.js","sourcesContent":["\"use strict\";\n\nvar _ = require(\"underscore\");\nvar Cookie = function Cookie(options) {\n  this.path = \"/\";\n  this.maxAge = null;\n  this.httpOnly = true;\n  //if (options) _.merge(this, options);\n};\n\nvar encode = encodeURIComponent;\nvar decode = decodeURIComponent;\n\nCookie.prototype.serialize = function (key, val) {\n\n  var serialize = function serialize(name, val, opt) {\n    opt = opt || {};\n    var enc = opt.encode || encode;\n    var pairs = [name + '=' + enc(val)];\n\n    if (opt.maxAge) pairs.push('Max-Age=' + opt.maxAge);\n    if (opt.domain) pairs.push('Domain=' + opt.domain);\n    if (opt.path) pairs.push('Path=' + opt.path);\n    if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString());\n    if (opt.httpOnly) pairs.push('HttpOnly');\n    if (opt.secure) pairs.push('Secure');\n\n    return pairs.join('; ');\n  };\n  return serialize(key, val, this);\n};\n\nvar setCurrentParseUser = function setCurrentParseUser(userSession) {\n  if (!userSession || !userSession.id || !userSession.sessionToken) {\n    // Force cleanup if invalid\n    Parse.User.logOut();\n    return;\n  }\n  Parse.User._currentUser = Parse.Object._create(\"_User\");\n  Parse.User._currentUser._isCurrentUser = true;\n  Parse.User._currentUser.id = userSession.id;\n  Parse.User._currentUser._sessionToken = userSession.sessionToken;\n  Parse.User._currentUser._synchronizeAllAuthData();\n  Parse.User._currentUser._refreshCache();\n  Parse.User._currentUser._opSetQueue = [{}];\n};\n\nvar getCurrentParseUserSession = function getCurrentParseUserSession() {\n  var u = Parse.User.current();\n  if (!u) {\n    return;\n  }\n  return { id: u.id, sessionToken: u.getSessionToken() };\n};\n\nmodule.exports = function (options) {\n  options = options || {};\n  var key = options.key || 'parse.sess';\n  var cookieOptions = options.cookie || {};\n  var forcedCookieOptions = { httpOnly: true, secure: true };\n  // forcedCookieOptions will overwrite same keys in cookieOptions\n  cookieOptions = _.defaults(forcedCookieOptions, cookieOptions);\n\n  return function parseExpressCookieSession(req, res, next) {\n\n    ////////////////////////\n    // Request path logic\n\n    // Expect express.cookieParser to set req.secret before this middleware.\n    var signatureSecret = req.secret;\n    if (_.isEmpty(signatureSecret)) {\n      throw new Error('express.cookieParser middleware must be included' + 'before this, and initialized with a signing secret');\n    }\n    var cookie = new Cookie(cookieOptions);\n\n    // Ignore if cookie path does not match.\n    if (req.originalUrl.indexOf(cookie.path) !== 0) {\n      return next();\n    }\n\n    // Decrypt and parse the signed cookie.\n    // Assume express.cookieParser already verified the signature and put the\n    // cookie's contents at req.signedCookies[key].\n    var reqParseUserSession;\n    var reqCookieJson; // Used later to determine whether to set response cookie.\n    var reqCookieBody = req.cookies[key];\n    if (!_.isEmpty(reqCookieBody)) {\n      try {\n\n        reqCookieJson = JSON.parse(reqCookieBody);\n        //reqParseUserSession = JSON.parse(reqCookieBody);//decrypt(reqCookieBody, encryptionSecret);\n        if (reqCookieJson && !reqCookieJson.id || !reqCookieJson.sessionToken) {\n          throw \"Invalid session\";\n        }\n        /*if (!Parse._.isEmpty(reqCookieJson)) {\n          reqParseUserSession = utils.parseJSONCookie(reqCookieJson);\n        }*/\n      } catch (e) {\n        // Catch any decryption and JSON parsing exceptions.\n        console.warn(\"Invalid Parse session cookie\");\n      }\n    }\n    setCurrentParseUser(reqCookieJson);\n    ////////////////////////\n    // Response path logic\n    res.on('header', function () {\n      var resParseUserSession = getCurrentParseUserSession();\n      // If user is logged out, clear cookie.\n      if (_.isUndefined(resParseUserSession)) {\n        cookie.expires = new Date(0);\n        res.setHeader('Set-Cookie', cookie.serialize(key, ''));\n        return;\n      }\n\n      // Only send Parse session cookies via https connection.\n      /*if (!req.secure) {\n        console.warn('Skipped setting Parse session cookie because request is not https');\n        return;\n      }*/\n\n      // Serialize. Prefix is Connect's convention for JSON in cookie.\n      resCookieJson = resParseUserSession;\n      // Skip Set-Cookie if cookie is same as request.\n      if (reqCookieJson !== resCookieJson) {\n        var val = JSON.stringify(resParseUserSession);\n        val = cookie.serialize(key, val);\n        res.setHeader('Set-Cookie', val);\n        // Encrypt and sign. Prefix is Connect's convention for signed cookie.\n        //var val = encrypt(resCookieJson, encryptionSecret);\n        //val = 's:' + signature.sign(val, signatureSecret);\n      }\n    });\n\n    if (options.fetchUser && !_isNullOrUndefined(Parse.User.current())) {\n      Parse.User.current().fetch().then(function (user) {\n        next();\n      }, function () {\n        // If user from cookie is invalid, reset Parse.User.current() to null.\n        Parse.User.logOut();\n        next();\n      });\n    } else {\n      next();\n    }\n  };\n};"]}